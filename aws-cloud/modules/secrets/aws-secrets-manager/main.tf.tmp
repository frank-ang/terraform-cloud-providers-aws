terraform {
  required_providers {
    aws = {
      source  = "hashicorp/aws"
      version = ">= 6.0"
    }
    kubernetes = {
      source  = "hashicorp/kubernetes"
      version = ">= 2.26.0"
    }
    helm = {
      source  = "hashicorp/helm"
      version = "~> 2.13"
    }
    kubectl = {
      source  = "gavinbunney/kubectl"
      version = ">= 1.7.0"
    }
  }
}


data "aws_caller_identity" "main" {}

data "terraform_remote_state" "database" {
  backend = "local"

  config = {
    path = "../database/terraform.tfstate"
  }
}

data "terraform_remote_state" "kubernetes_cluster" {
  backend = "local"

  config = {
    path = "../kubernetes_cluster/terraform.tfstate"
  }
}

data "terraform_remote_state" "cluster_services" {
  backend = "local"

  config = {
    path = "../cluster_services/terraform.tfstate"
  }
}

locals {
  eks_cluster_endpoint                   = data.terraform_remote_state.kubernetes_cluster.outputs.eks_cluster_endpoint
  eks_cluster_certificate_authority_data = data.terraform_remote_state.kubernetes_cluster.outputs.eks_cluster_certificate_authority_data
  eks_cluster_name                       = data.terraform_remote_state.kubernetes_cluster.outputs.eks_cluster_name
  eks_oidc_provider_arn                  = data.terraform_remote_state.kubernetes_cluster.outputs.eks_oidc_provider_arn
  aws_account_id = data.aws_caller_identity.main.account_id
  database_hostname                        = data.terraform_remote_state.database.outputs.cluster_endpoint
  database_credentials_admin_user_password = data.terraform_remote_state.database.outputs.database_credentials_admin_user_password
  cert_manager_selfsigned_cluster_issuer   = data.terraform_remote_state.cluster_services.outputs.cert_manager_selfsigned_cluster_issuer
  ingress_class_name                       = data.terraform_remote_state.cluster_services.outputs.ingress_class_name
  root_db_secrets_name        = "root-db-secrets"
  dummy_saml_idp_secrets_name = "dummy-saml-idp-secrets"

  sscd_chart_name   = "secrets-store-csi-driver"
  sscd_namespace    = "kube-system"
  sscdpa_chart_name = "secrets-store-csi-driver-provider-aws"
  sscdpa_namespace  = "kube-system"
}



provider "kubernetes" {
  #host                   = local.eks_cluster_endpoint
  #cluster_ca_certificate = base64decode(local.eks_cluster_certificate_authority_data)

  exec {
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    # This requires the awscli to be installed locally where Terraform is executed
    args = ["eks", "get-token", "--profile", var.aws_profile, "--cluster-name", local.eks_cluster_name]
  }
}

provider "helm" {
  kubernetes {
    config_path = "~/.kube/config"
    config_context = var.eks_cluster_arn
    #host                   = local.eks_cluster_endpoint
    #cluster_ca_certificate = base64decode(local.eks_cluster_certificate_authority_data)

    #exec {
    #  api_version = "client.authentication.k8s.io/v1beta1"
    #  command     = "aws"
    #  # This requires the awscli to be installed locally where Terraform is executed
    #  args = ["eks", "get-token", "--profile", var.aws_profile, "--cluster-name", local.eks_cluster_name]
    #}
  }
}

provider "kubectl" {
  host                   = local.eks_cluster_endpoint
  cluster_ca_certificate = base64decode(local.eks_cluster_certificate_authority_data)
  exec {
    api_version = "client.authentication.k8s.io/v1beta1"
    command     = "aws"
    # This requires the awscli to be installed locally where Terraform is executed
    args = ["eks", "get-token", "--profile", var.aws_profile, "--cluster-name", local.eks_cluster_name]
  }
}


# nosemgrep: resource-not-on-allowlist
resource "helm_release" "sscd" {
  name       = local.sscd_chart_name
  repository = "https://kubernetes-sigs.github.io/secrets-store-csi-driver/charts"
  chart      = local.sscd_chart_name
  namespace  = local.sscd_namespace
  set {
    name  = "linux.priorityClassName"
    value = "high-priority"
  }
  depends_on = [
    kubernetes_priority_class.high_priority
  ]
}

# nosemgrep: resource-not-on-allowlist
resource "helm_release" "sscdpa" {
  name       = local.sscdpa_chart_name
  repository = "https://aws.github.io/secrets-store-csi-driver-provider-aws"
  chart      = local.sscdpa_chart_name
  namespace  = local.sscdpa_namespace
  set {
    name  = "priorityClassName"
    value = "high-priority"
  }
  depends_on = [
    kubernetes_priority_class.high_priority
  ]
}

# nosemgrep: resource-not-on-allowlist
resource "kubernetes_priority_class" "high_priority" {
  metadata {
    name = "high-priority"
  }
  value          = 1000000
  global_default = false
  description    = "This priority class should be used for essential services."
}

data "aws_iam_policy_document" "aws_sm_applications_permission_boundary" {
  statement {
    sid = "AllowGetSecretsOnlyInPath"
    effect = "Allow"
    actions = [
      "secretsmanager:GetSecretValue"
    ]
    resources = [
      "arn:aws:secretsmanager:${var.aws_region}:${local.aws_account_id}:secret:${var.tm_iam_prefix}/*",
    ]
  }
}

resource "aws_iam_policy" "aws_sm_applications_permission_boundary" {
  name        = "${var.project}-vault-role-permission-boundary"
  description = "TM Vault applications permissions to AWS Secret Manager"
  policy      = data.aws_iam_policy_document.aws_sm_applications_permission_boundary.json
}


# database root password
resource "aws_secretsmanager_secret" "aws_sm_root_db_secrets" {
  name                    = "${var.tm_iam_prefix}/${var.secret_prefix}/${local.root_db_secrets_name}"
  description             = "TM database root credentials"
  recovery_window_in_days = 0
}

locals {
  aws_sm_root_db_secrets_secret_value = {
    "${local.database_hostname}" = local.database_credentials_admin_user_password
  }
}

resource "aws_secretsmanager_secret_version" "aws_sm_root_db_secrets" {
  secret_id     = aws_secretsmanager_secret.aws_sm_root_db_secrets.id
  secret_string = jsonencode(local.aws_sm_root_db_secrets_secret_value)
}

# dummy idp password
resource "aws_secretsmanager_secret" "aws_sm_dummy_saml_idp" {
  name                    = "${var.tm_iam_prefix}/${var.secret_prefix}/${local.dummy_saml_idp_secrets_name}"
  description             = "For SAML authentication. The values must match common.basic_auth.password and common.basic_auth.username in the prepared values.yaml"
  recovery_window_in_days = 0
}


resource "aws_secretsmanager_secret_version" "aws_sm_dummy_saml_idp" {
  secret_id     = aws_secretsmanager_secret.aws_sm_dummy_saml_idp.id
  secret_string = jsonencode(var.basic_auth_credentials)
}
